<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>Grupo 7 KNN </title>
  <link rel="stylesheet" href="./style.css">

</head>
<body>
<!-- partial:index.partial.html -->
<!-- The library is included in this pen's javascript settings, but the following is also possible: -->
<!--<script src="https://rawgit.com/StefanieStoppel/d3ML/master/lib/d3ml.min.js"></script>-->
<h1 class="center">K-Nearest Neighbor (KNN)</h1>
<br>
<div id="knn"></div>
<div class="description">
<p>
  En la visualización, puede ver cómo el algoritmo de k vecino más cercano (KNN) 
  clasifica nuevos puntos de datos en función de sus k vecinos más cercanos,
   donde la cantidad de vecinos k se especifica usando el control deslizante de arriba.
  <br> Al nuevo punto se le asignará la clase que tenga la mayoría de sus k vecinos más 
  cercanos.
</p>
<ol>
  <li>El algoritmo recorre todos los demás círculos y calcula su distancia desde su nuevo círculo.</li>
  <li>Luego, los clasifica por distancia desde su círculo en orden ascendente, lo que significa que los círculos con las distancias más pequeñas al nuevo círculo son lo primero.</li>
  <li>Toma las primeras k entradas del resultado del paso 2.</li>
  <li>Mira las k clases de vecinos más cercanos. Si la mayoría de ellos son azules, nuestro nuevo punto también será azul. Si la mayoría de ellos son rojos, el nuevo punto será rojo.</li>
</ol>
<h3>The weighted KNN</h3>
<p>
  If you check the <strong>"Weighted" checkbox</strong> above, the algorithm is justified, so that the <strong>inverse of the distance</strong> of the k neighbors is taken into account. This is important during "ties", meaning that you chose an even amount of neighbors k and half of them are class red while the other half are blue. 
  If you don't use the weighted version of KNN in this case, the neighbor with the closest distance will <strong>ALWAYS</strong> win, so that your circle will take on its color. 
<p>
<h4>Let's look at an example:</h4>
<p>
  Imagine you chose <strong>k=4</strong> and the nearest neighbors are <strong>[(Blue,2), (Blue,500), (Red,3), (Red,4)]</strong>, where the numbers represent the distances from the new circle. In the unweighted KNN, the nearest neighbor's class - in this case Blue - would automatically win. But look at the distances: The two red circles are much closer to the new circle than the second blue circle. It might not be the right decision to just go on the closest circle and not take the others into account!
<br><br>
    When using the <strong>weighted KNN</strong>, the way of determining which class to assign to the new circle is different:<br>
  The weighted KNN sums up the <strong>inverted distance</strong> of all the nearest neighbors belonging to the <strong>same class</strong>. It then checks which of the classes' <strong>sums is the greatest</strong> and assigns the corresponding class to the new circle.<br><br>
  In our example the weights of the classes are:
</p>
<ul>
  <li>Weight of Blue = 1/2 + 1/500 = 0.502</li>
  <li>Weight of Red = 1/3 + 1/4 = 0.583</li>
</ul>
<p>
Because the weight of class Red is greater than that of class Blue, the new circle will be <strong>red</strong>!<br>
</div>
<!-- partial -->
  <script src='https://cdn.jsdelivr.net/gh/StefanieStoppel/d3ML@develop/lib/d3ml.min.js'></script><script  src="./script.js"></script>

</body>
</html>
